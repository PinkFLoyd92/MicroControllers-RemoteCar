// LCD module connections
sbit LCD_RS at RB4_bit;
sbit LCD_EN at RB5_bit;
sbit LCD_D4 at RB0_bit;
sbit LCD_D5 at RB1_bit;
sbit LCD_D6 at RB2_bit;
sbit LCD_D7 at RB3_bit;

sbit LCD_RS_Direction at TRISB4_bit;
sbit LCD_EN_Direction at TRISB5_bit;
sbit LCD_D4_Direction at TRISB0_bit;
sbit LCD_D5_Direction at TRISB1_bit;
sbit LCD_D6_Direction at TRISB2_bit;
sbit LCD_D7_Direction at TRISB3_bit;
// End LCD module connections

/* -----------------------LCD TEXTO-------------- */
char txtDefault[] = "Esperando Seleccion de Modo (Automático/Manual)...";
char txtArriba[] = "Arriba...";
char txtIzquierda[] = "Izquierda...";
char txtDerecha[] = "Derecha...";
char txtAbajo[] = "Abajo...";
char txtAutomatic[] = "Automatico";

/* ----------------------ADC--------------------- */
unsigned int temp_res_forward;
unsigned int temp_res_backward;

/*-----------------------UART-------------------- */
char uart_rd;                   /* char leido enviado desde aplicacion Android */
char uart_rd_temp;
int bandera_mover = 1;          /* Por defecto, se puede mover, si sensor detecta tropiezo,
                                   no mueve */
int bandera_automatico = 1;
/* HABILITACION INTERRUPCION */
contadorInterrupt = 0;

/* Funcion usada en modo automatico para esquivar obstaculo */
void darVuelta(){

}
void moverManual(){
  bandera_automatico = 0;       /* Se limpia la bandera de automatico por si acaso. */
  while (uart_rd_temp != 'e') { /* Si se le envía e se sale de modo manual */
    if (uart_rd_temp == 'u' && bandera_mover) { /* Up: En la interrupción para el auto */
      Lcd_Out(2,6,txtArriba);
    }
    else if (uart_rd_temp == 'd' && bandera_mover) { /* Down:  */
      Lcd_Out(2,6,txtAbajo);
    }
    else if (uart_rd_temp == 'l' && bandera_mover) { /* left:  */
      Lcd_Out(2,6,txtAbajo);
    }
    else if (uart_rd_temp == 'r' && bandera_mover) { /* right:  */
      Lcd_Out(2,6,txtAbajo);
    }
  }
}

/* Avanzar vehiculo */
void avanzarVehiculo(){
  RC1_bit = 1;
  RC2_bit = 1;
  RC7_bit = 0;
  RC6_bit = 0;
}
/* Logica para detener el vehiculo. */
void pararVehiculo(){
  RC1_bit = 0;
  RC2_bit = 0;
  RC7_bit = 0;
  RC6_bit = 0;
}

/* 2 Motores: motor derecha es ccp2, motor izquierda es ccp1
   giroderecha: detener motor derecha, mover izquierdo*/
void girarDerecha(){
  RC1_bit = 1;
  RC2_bit = 0;
  RC5_bit = 0;
  RC4_bit = 0;
  Delay_ms(2000);               /* 2 segundos de giro */
  /* Se para el carro con la posicion ya girada. */
  RC1_bit = 0;
  RC2_bit = 0;
  RC7_bit = 0;
  RC6_bit = 0;

}
/*   giroizquierda: mover motor derecha, detener izquierdo*/
void girarIzquierda(){
  RC1_bit = 0;
  RC2_bit = 1;
  RC5_bit = 0;
  RC4_bit = 0;
  Delay_ms(2000);               /* 2 segundos de giro */
  /* Se para el carro con la posicion ya girada. */
  RC1_bit = 0;
  RC2_bit = 0;
  RC7_bit = 0;
  RC6_bit = 0;
}

/*   giroizquierda: mover motor derecha, detener izquierdo*/
void moverAtras(){
  RC1_bit = 0;
  RC2_bit = 0;
  RC5_bit = 1;
  RC4_bit = 1;
}
void moverEnAutomatico(){
  bandera_automatico = 1;       /* Con esta bandera se valida en la interrupcion que hacer cuando ocurre un choque. */
  while (uart_rd_temp != 'e') { /* Si se le envía e se sale de modo automatico. */
    if(UART1_Data_Ready())
      uart_rd_temp = UART1_Read();
    Lcd_Out(2,6,txtAutomatic);
    /* Movimiento hacia adelante de los autos. */
    RC1_bit = 1;
    RC2_bit = 1;
    RC5_bit = 0;
    RC4_bit = 0;


    if(UART1_Data_Ready())
      uart_rd_temp = UART1_Read();

  }
  bandera_automatico = 0;       /* al enviar e se sale de modo automatico.*/
}
int checkADC(valor){                    /* Revisar valor dado del sensor de ultrasonido,
                                           si está cerca de choque, se cambia bandera a 0*/
  bandera_mover = 1;
  return -1;
}
/* Interrupciones: ADC */
void interrupt(){
  /* Interrupción para obtener datos del adc */

  /*  if (PIR1.ADIF) {
      temp_res = ADC_Get_Sample(2);       // analog value from channel 2
      checkADC(temp_res);
      PIR1.ADIF = 0;              // Limpiar bandera
      }*/

  // If the interrupt was generated by timer0 overflow
  if(INTCON.T0IF && contadorInterrupt == 20{
      // Place ADC code here
      temp_res_forward = ADC_Read(2);
      checkADC(temp_res_forward); /* Se revisa si hay o no un obstaculo, si hay la bandera_mover cambia a 0 */
      if(!bandera_mover && bandera_automatico){ /* Si hay obstaculo y esta en Automatico*/
        darVuelta();
      }
      INTCON.T0IF = 0;          /* borrar bandera */
      contadorInterrupt = 0;    /* resetear contador de entradas a interrupcion */
      return;
    }
    contadorInterrupt++;                /* contando 20 entradas a la interrupcion */
    }
  void main() {
    ANSEL  = 0b00001100;              // Configure AN2/AN3 pin as analog
    ANSELH = 0;
    C1ON_bit = 0;                      // Disable comparators
    C2ON_bit = 0;
    INTCON = 0b10100000; // INTERRUPCION POR TIMER0 Y GIE ACTIVADOS.
    /* INTCON.T0IE = 1;                 /\* Activado interrupcion por timer0 *\/ */
    OPTION_REG = 0b10000111; //  TMR0 temporizado:  RBPU, TOCS= INTERNAL INSTRUCTION CLOCK= 0 PSA =0   1:256
    TRISC = 0;                          // PUERTOC COMO SALIDA
    PORTC = 0;                          // LIMPIAR PUERTOC
    /* PWM1_Init(5000);                    // Initialize PWM1 module at 5KHz */
    /* PWM2_Init(5000);                    // Initialize PWM2 module at 5KHz */
    /* PWM1_Start();                       // start PWM1 */
    /* PWM2_Start();                       // start PWM2 */
    /* PWM1_Set_Duty(16);        // Set current duty for PWM1 */
    /* PWM2_Set_Duty(16);       // Set current duty for PWM2 */

    Delay_us(10);                 /* wait for acquisition time*/
    UART1_Init(9600);                         // initialize UART1 module
    Delay_ms(100);                  // Wait for UART module to stabilize

    Lcd_Init();                        // Initialize LCD
    /* Programa principal */
    Lcd_Out(2,0,txtDefault);                 // Write text in second row
    while (1) {
      Lcd_Out(2,0,txtDefault);                 // Write text in second row
      if (UART1_Data_Ready()) {     // If data is received,
        uart_rd = UART1_Read();     // leer el dato recibido del celular
        /* uart_rd = 'A'; */
        switch (uart_rd) {
        case 'A': {               /* Modo automático */
          Lcd_Out(2,6,txtAutomatic);
          moverEnAutomatico();
          break;
        }
        case 'M': {
          moverManual();
          break;
        }
        default:
          break;
        }
      }
    }
  }
